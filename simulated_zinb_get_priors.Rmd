---
title: "ZeroInflatedPoisson"
author: "Anders Sundelin"
date: "2022-10-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(boot)
```

# Simulating Issue Introduction and Removal with Zero-inflated Negative Binomial and brms

The goal of this Rmd is to arrive at reasonably sane, scientifically grounded priors.

In order to do so, we will simulate data that conceptually "look like" the data we see "in the wild".
This is done just to assess the quality of the priors, and does not imply that the true data-generating process obeys the same forumla.
We merely want to assess the strength of the priors (in order to not make them too strong, as that would prevent the posterior from dominating the priors.

## Inventing Data Points

We know that our data for both ADD, DUP and COMPLEX are very right-skewed. We use an exponential distribution to construct similar data, that looks reasonably like our own (within the same order of magnitude).

With some experimentation, we find that the following function produces data with a reasonable shape:

```{r}
N <- 350
set.seed(20230104)

ADD <- exp(rexp(N, 0.85))-1
COMPLEX <- exp(rexp(N, 0.85))-1
DUP <- exp(rexp(N, .85))-1
```

The main thing to look for is the maximum value (is it reasonable, within an order of magnitude), number of zeros/extremely low values, and the shape in between. We want to have a sharp right-skewed distribution, as that is how our own data looks like.

All three of our predictors have a similar shape, so we use the same formula to simulate them, though all use repeated draws from the exponential distribution.

```{r}
data.frame(add=ADD) |> ggplot(aes(x=add)) + geom_histogram(binwidth = 1) + ggtitle("Simulated ADD data")
```

We could experiment with other distributions and parameters, such as the log-normal distribution. Each distribution have their set of parameters

```{r}
otherADD <- rlnorm(350, -0.5, 2.5)
data.frame(add=otherADD)  |> ggplot(aes(x=add)) + geom_histogram(binwidth=1) + ggtitle("Simulated ADD data using lognormal")
```

```{r}
summary(ADD)
```

```{r}
summary(otherADD)
```

Which distribution we use is not that important, just that its values are reasonably true to the form of the collected data.

Due to the right-skewedness, our model uses the logarithm of the datapoints in the linear regression. Otherwise the very few extreme values will have extremely high leverage over the shape of the linear model.
This also means that the linear model will be based on the _magnitude_ of the change in parameter (e.g. 0, 1, 2.7, 7.3, 19.8 added lines/existing complexity). So each individual line will have marginally lower impact, but the scale of the parameter will still matter.

```{r}
logADD <- log(ADD+1)
logCOMPLEX <- log(COMPLEX+1)
logDUP <- log(DUP+1)
```

As we know that our true parameters have a lower bound of 0, we add 1 to the parameter before taking the logarithm.

Our linear regression parameters are less spread out, but the lower bound is still 0 (meaning zero added lines):

```{r}
data.frame(logADD=logADD) |> ggplot(aes(x=logADD)) + geom_histogram(bins = 50) + ggtitle("Simulated logADD data")
```

So, now we have three parameters that should reasonably well resemble our own data, even if the underlying process is totally different.

We follow recommendations from McElreath and others, and scale our log values.
```{r}
A <- scale(logADD)
C <- scale(logCOMPLEX)
D <- scale(logDUP)

summary(A)
```

```{r}
data.frame(A=A) |> ggplot(aes(x=A)) + geom_histogram(bins = 50) + ggtitle("Scaled simulated logADD data")
```

This means that the intercept parameter (0) is to be interpreted as the `mean magnitude` of the parameter.
Negative values represent values with a lower magnitude, and higher represent a higher magnitude.

## Inventing a Linear Model based on our generated data

Next, we come up with some coefficients that we want our priors and our model to retrieve.

Thinking about the true data generating process, we state the following:

Because of scaling, our intercept will reflect the mean magnitude of the parameters.

It is likely that there are zero issues introduced if there are very few lines added or removed. 
So the zero inflation part of the model should reflect the number of added lines - when the number of added lines are low, there should be a comparatively high chance of introducing zero issues.

Furthermore, it seems likely that the direction of the relationship between predictors and logLambda would be positive, or at least non-negative, overall. We do not expect the number of introduced issues to decrease as either of the predictors increase (but the effect could still be zero, i.e. no relationship)

For our analysis, we use the following formula:

```{r}
logLambda <- -0.25 +  0.6 * A + 0.5 * C + 0.3 * D
data.frame(logLambda=logLambda) |> ggplot(aes(x=logLambda)) + geom_histogram(bins = 50)
```

Check that the generated data produces reasonably well behaved outcomes

```{r}
data.frame(lambda=exp(logLambda)) |> ggplot(aes(x=lambda)) + geom_histogram(bins = 400)
```
```{r}
data.frame(lambda=exp(logLambda)) |> ggplot(aes(x=lambda)) + geom_histogram(bins = 400) + xlim(0,100)
```

Construct the full negative binomial model. 

```{r}
mu <- exp(logLambda)
size <- 5#*teams + authors
data.frame(count=rnbinom(350, mu=mu, size=size)) |> ggplot(aes(x=count)) + geom_histogram(bins=400)
```

Now construct the zero-inflation part. We start off with keeping 25% (essentially zeroing out 75% of the NB part).



```{r}
untouched_logit <- logit(0.80) - 0.5 * A
data.frame(p=inv.logit(untouched_logit)) |> ggplot(aes(x=p)) + geom_histogram(bins = 100)
p <- inv.logit(untouched_logit)
```
```{r}
prob_untouched <- p
untouched <- rbinom(N, 1, prob_untouched)
introd <- (1-untouched) * rnbinom(N, mu=mu, size=size)
```


This gives the following distribution of data.

```{r}
data.frame(introd=introd) |> ggplot(aes(x=introd)) + geom_histogram(bins=400)
```
```{r}
summary(introd)
```


So, we have very many zeros (about 300 out of 350, then some parts that range up to a few hundred issues). But most of the non-zeros are below 10-20.

Can we use this data to recover our parameters from the linear model? 

## Recovering the model parameters

```{r}
library(brms)
library(tidybayes)
library(bayesplot)
```

Argumenting for the priors:

* As stated above, we do suspect that the intercept will be moderatly negative (or at least not positive). It is very unlikely that issues can be introduced if there are no changes in any other parameter.
* For the betas on logADD, logDUP and logCOMPLEX, we take a cautious approach, and state a prior or Normal(0, 0.25). On the log-scale, this means that on average, we expect "no change" for a beta, but allow 95% of the prior probability to vary between -0.5 and 0.5 (+/- 2 std.dev from mean).
* We do expect the intercept for the zero-inflation to be positive. At 0, the logit-link of the zi-part determines that there is 50% chance of seeing a zero. And we have many more zeros in our data than 50% (about 80%, judging from the histogram above). We set a prior of Normal(1, 0.25), which corresponds to having 95% probability between $inv_logit(0.5) = 0.62$ and $inv_logit(1.5) = 0.81$.
* The shape parameter is really tricky. With some experimentation, we decide to move away from the default $gamma(0.01,0.01)$ to $gamma(0.1, 0.1)$. The basis for this is the large number of large Pareto k-values (over 10% of the observations)


```{r}
d <- data.frame(y=introd, logADD=A, logDUP=D, logCOMPLEX=C)
M_recover_params <- brm(data=d,
                        family=zero_inflated_negbinomial,
                        formula=bf(y ~ 0 + Intercept + logADD + logDUP + logCOMPLEX ,
                                   zi ~ 1 + logADD),
                        prior = c(prior(normal(-2, 1), coef = Intercept),
                                  prior(normal(0, 0.25), class = b),
                                  prior(normal(1, 0.25), class = Intercept, dpar=zi),
                                  prior(gamma(0.1, 0.01), class = shape)),
                        warmup=1000,
                        iter=2000,
                        chains=4,
                        cores=4,
                        backend="cmdstanr",
                        save_pars = save_pars(all=T),
                        adapt_delta=0.95)
```

Note that we chose the non-auto-centered version of the intercept - this is so we can keep our natural interpretation of the intercept (as outlined above). The default brms way `1 + ...` will otherwise automatically center the data based on the mean of the parameters. This will affect the interpretation of the prior of the intercept, but not the final result, when the process will be reversed.

For this particular data, there is not much difference if we choose the centered version of the intercept (the mean are close to 0 anyways). But for other models it might differ a lot. if you have a scientific motivation for your intercept data.

```{r}
M_recover_params_autocentered <- brm(data=d,
                        family=zero_inflated_negbinomial,
                        formula=bf(y ~ 1 + logADD + logDUP + logCOMPLEX,
                                   zi ~ 1),
                        prior = c(prior(normal(0, 1), class = Intercept),
                                  prior(normal(0, 0.25), class = b),
                                  prior(normal(1, 0.25), class = Intercept, dpar=zi),
                                  prior(gamma(0.1, 0.1), class = shape)),
                        warmup=1000,
                        iter=2000,
                        chains=2,
                        cores=2,
                        backend="cmdstanr",
                        save_pars = save_pars(all=T),
                        adapt_delta=0.95)

```



```{r}
m <- M_recover_params # or M_recover_params_autocentered
stopifnot(rhat(m) < 1.01)
stopifnot(neff_ratio(m) > 0.2)
mcmc_trace(m) # ok
loo <- loo(m) 
```
We have one LOO value above 0.7

```{r}
loo <- loo(m, moment_match = T, reloo=T)
plot(loo)
```
```{r}
m <- add_criterion(m, "loo")
loo
```
When enabling moment matching on the model, the influential Pareto k value disappears. 

How does Rhat and neff_ratio compare?

```{r}
rhat(m) |> mcmc_rhat()
neff_ratio(m) |> mcmc_neff() # + scale_x_continuous(limits=c(0, 0.5))
```
All $\hat{R}$ values are ok (close to 1), and also the n_eff_ratio are much greater than 0.1, which is commonly used as a cut-off threshold.

We should be able to trust our model.

How does it compare?

```{r}
summary(m)
```

The zero-inflation intercept are estimated to be $inv_logit(1.24)$, which corresponds to 

```{r}
inv.logit(1.04)
```

This is close to our original parameter, 0.75, for only 350 data points. If we had more data, we would get closer.

Credible interval would be between 0.725 and 0.81, which is very close to 0.75

```{r}
inv.logit(c(0.72, 1.35))
```

The intercept is estimated to be between -1.65 and -0.95, with a point estimate of -1.3, close to our specified -1.5 target.

The coefficient for logADD are specified as between 0.82 and 0.94, with a point estimate of 0.88. The real value is 0.90, close to the estimate.

The coefficient for logDUP are specified as between 0.05 and 0.23, with a point estimate of 0.14, slightly lower than the real 0.20.
Likewise, the estimate for logCOMPLEX are specified as between 0.60 and 0.71, with a point estimate of 0.66, slightly lower than the real 0.70.


### Conditional effects
```{r}
nd <- d |> mutate(logADD=0, logDUP=0, logCOMPLEX=seq(from=-2, to=5, length.out=350))

f <- fitted(m, newdata=nd, probs=c(.055, .945)) |> data.frame() |> bind_cols(nd)
f |> ggplot(aes(x=logCOMPLEX)) + geom_smooth(aes(y=Estimate, ymin=Q5.5, ymax=Q94.5), stat="identity", alpha=.25, size=.5) + 
  geom_point(data=bind_cols(d, m$criteria$loo$diagnostics), aes(y=y, size = pareto_k), alpha=0.8)
```
Rescaling

```{r}
f |> ggplot(aes(x=logCOMPLEX)) + geom_smooth(aes(y=Estimate, ymin=Q5.5, ymax=Q94.5), stat="identity", alpha=.25, size=.5) + 
  geom_point(data=bind_cols(d, m$criteria$loo$diagnostics), aes(y=y, size = pareto_k), alpha=0.8) + scale_y_continuous(limits=c(0,25))

```

Much of the pull upwards are being done by the outlier.


## Posterior predictions

We can visualize how our model compares related to the simulated data by doing posterior predictive checks.

```{r}
yrep_zinb <- posterior_predict(m)
```

The proportion of zeros fall straight in line with the observed ratio, about 0.84. These are zeros occurring regardless of the zero-inflation or the negative binomial. Our model thinks that about 77%-86% of commits would have zero issues introduced. The real (simulated) proportion is about 84%.

```{r}
ppc_stat(y = d$y, yrep_zinb, stat = function(y) mean(y == 0))
```

The maximum value simulated ranges between 100 to about 2000. The larger values are unrealistic, and in particular the peak around 1000 seems to warrant further scrutiny. But the largest peak occurs straight where we expected the max value to be (which was 257 issues, according to our simulation).

```{r}
ppc_stat(y = d$y, yrep_zinb, stat = "max") # + scale_x_continuous(limits=c(0,2000))
```

```{r}
max(yrep_zinb)
```

For ZINB distributions, suspended rootograms are recommended by Kleiber and Zeileis (2016).
These rootograms show the difference between observed and expected counts, with bars hanging from the zero-line rather than the expected count line. Therefore we can think of this rootogram as showing information about the model residuals.

```{r}
pp_check(m, type = "rootogram", style="suspended")
```


```{r}
pp_check(m, type = "rootogram", style="suspended") + scale_x_continuous(limits = c(0,100)) + ggtitle("Suspended rootogram beween 0 and 100.")

```

It appears that the priors did their job, and allowed the data to shine through.


The conditional effect show the effect of varying one parameter, keeping all the others in the model constant (usually at their mean value). We see the comparatively larger impact of logADD and logCOMPLEX, relative to logADD (as we specified in our model, by giving them larger coefficients).

```{r}
plot(conditional_effects(m), ask = FALSE)

```
Graphically inspecting the parameters can also be done via mcmc_areas:

```{r}
mcmc_areas(m, regex_pars = c("^b_", "^b_zi"))
```

### Prior predictive checks

We can get some truly awful priors 

```{r}
M_horrible_prior_selection <- brm(data=d,
                        family=zero_inflated_negbinomial,
                        formula=bf(y ~ 0 + Intercept + logADD + logDUP + logCOMPLEX,
                                   zi ~ 1),
                        prior = c(prior(normal(0, 0.1), coef = Intercept),
                                  prior(normal(0, 0.01), class = b),
                                  prior(normal(0, 0.6), class = Intercept, dpar=zi),
                                  prior(gamma(0.1, 1), class = shape)),
                        sample_prior = "only",
                        warmup=1000,
                        iter=2000,
                        chains=2,
                        cores=2,
                        backend="cmdstanr",
                        save_pars = save_pars(all=T),
                        adapt_delta=0.95)
```

```{r}
loo(M_horrible_prior_selection)
```

With the horrible priors, we get 16% awful Pareto values.
```{r}
yrep_zinb <- posterior_predict(M_horrible_prior_selection)
ppc_stat(y = d$y, yrep_zinb, stat = function(y) mean(y == 0))
ppc_stat(y = d$y, yrep_zinb, stat = "max") # + scale_x_continuous(limits=c(0,2000))
max(yrep_zinb)
```

There are instances of around 20000 introduced issues. Also, we see that the zero-inflation is highly overestimated (many cases of proportion of zeros being close to 1.0)

With default shape priors (gamma(0.01, 0.01)), we get lot of 10% Pareto values > 0.7 and 10% > 1.0. This gamma(0.1,0.1) is better.
```{r}
get_prior(data=d,
                        family=zero_inflated_negbinomial,
                        formula=bf(y ~ 0 + Intercept + logADD + logDUP + logCOMPLEX,
                                   zi ~ 1 + logADD))
```

https://bookdown.org/content/4857/monsters-and-mixtures.html
Within brms, priors using the gamma distribution are based on the shape-rate (α-θ) parameterization. This is what Gamma(0.01,0.01) looks like

```{r}
ggplot(data = tibble(x = seq(from = 0, to = 60, by = .1)),
       aes(x = x, y = dgamma(x, shape = 0.1, rate = 0.01))) +
  geom_area(color = "transparent", fill = "green") +
  scale_x_continuous(NULL) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = c(0, 50)) +
  ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
```


```{r}
M_prior_selection <- brm(data=d,
                        family=zero_inflated_negbinomial,
                        formula=bf(y ~ 0 + Intercept + logADD + logDUP + logCOMPLEX,
                                   zi ~ 1 + logADD),
                        prior = c(prior(normal(0, 0.25), class = b),
                                  prior(normal(0, 0.5), class = b, coef = Intercept),
                                  prior(normal(0.1, 0.5), class = Intercept, dpar=zi),
                                  prior(normal(0, 0.25), class = b, dpar=zi),
                                  prior(gamma(0.75, 1), class = shape)),
                        sample_prior = "only",
                        warmup=1000,
                        iter=2000,
                        chains=2,
                        cores=2,
                        backend="cmdstanr",
                        save_pars = save_pars(all=T),
                        adapt_delta=0.95)

```



Having the default prior on shape (0.01, 0.01) leads to very many divergent transitions.

```{r}
m <- M_prior_selection

loo(m)
```

All Pareto k values are bad! Can we get more informed priors?
```{r}
yrep_zinb <- posterior_predict(m)

ppc_stat(y = d$y, yrep_zinb, stat = function(y) mean(y == 0))
ppc_stat(y = d$y, yrep_zinb, stat = "max")

```


```{r}
ppc_stat(y = d$y, yrep_zinb, stat = "max", binwidth=10) + xlim(0,200)

```


```{r}
max(yrep_zinb)
```

Plot in different scale

```{r}
ppc_stat(y = d$y, yrep_zinb, stat = "max") + scale_x_continuous(limits = c(0,400))

```

Seem to be overestimating the zero-inflation here too

### Scientific model

Whilr it would be tempting to use the same scientific argument for our model as McElreath in the Oceanic tools example, we do have parameters where the impact of zero is not 
Not using any log link for the $mu$, keeping the intercept 


### Having too restrictive priors

Specifying too restrictive priors will lead to the data not being allowed to tell its tale.
The priors will reflect back in the posterior.

This is an example where we restrict the betas very much, by setting sd to 0.01.

```{r}
d <- data.frame(y=introd, logADD=A, logDUP=D, logCOMPLEX=C)
M_worse_priors <- brm(data=d,
                        family=zero_inflated_negbinomial,
                        formula=bf(y ~ 1 + logADD + logDUP + logCOMPLEX,
                                   zi ~ 1),
                        prior = c(prior(normal(0, 1), class = Intercept),
                                  prior(normal(0, 0.01), class = b),
                                  prior(normal(0, 0.4), class = Intercept, dpar=zi),
                                  prior(gamma(0.1, 0.01), class = shape)),
                        warmup=1000,
                        iter=2000,
                        chains=2,
                        cores=2,
                        backend="cmdstanr",
                        save_pars = save_pars(all=T),
                        adapt_delta=0.95)

```

```{r}
m <- M_worse_priors

loo(m)
```

There is only one bad Pareto k value.

```{r}
loo <- loo(m, moment_match=T, reloo=T)
m <- add_criterion(m, "loo")
```

All Pareto k values are bad! Can we get more informed priors?
```{r}
yrep_zinb <- posterior_predict(m)

ppc_stat(y = d$y, yrep_zinb, stat = function(y) mean(y == 0))
ppc_stat(y = d$y, yrep_zinb, stat = "max")

```

The zero-intercept prior is OK, the observed value lies in the middle of the resulting distribution.
However, the model seems to severely underestimate the mean (rate), as there are a strong bias towards max values around 30-40, relative to the observed ~180.

```{r}
max(yrep_zinb)
```



```{r}
pp_check(m, type = "bars") #+ ylim(0, 40) + xlim(1, 40)
```

The conditional effects show three very flat betas for the three priors.

```{r}
plot(conditional_effects(m), ask = FALSE)

```

```{r}
summary(m)
```

This model, likely has too restrictive priors. The data is not allowed to tell its tale...

Plotting the data together with the model

```{r}

nd <- d |> select(logADD, logDUP) |> mutate(logCOMPLEX = seq(from=-2, to=4, length.out=350))

f <- fitted(m, newdata=nd, probs=c(.055, .945)) |> data.frame() |> bind_cols(nd)
f |> ggplot(aes(x=logCOMPLEX)) + geom_smooth(aes(y=Estimate, ymin=Q5.5, ymax=Q94.5), stat="identity", alpha=.25, size=.5) + 
  geom_point(data=bind_cols(d, m$criteria$loo$diagnostics), aes(y=y, size = pareto_k), alpha=0.8)
```


### Recovering the model parameters (zi-poisson)
